<!DOCTYPE html>
<html lang="en">
<head>
    <!--
    ================================================================================================================
    |                            METADATA & SEO OPTIMIZATIONS                                                        |
    ================================================================================================================
    -->
    <meta charset="UTF-8">
    <title>Neotropolis - An Interactive WebGL Shader Experience</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Explore Neotropolis, a real-time, interactive WebGL shader art experience. Customize psychedelic, abstract cityscapes and visual effects directly in your browser.">
    <meta name="keywords" content="Neotropolis, WebGL, shader, generative art, interactive art, real-time graphics, creative coding, digital art, visualizer, webgl demo">
    <meta name="author" content="Chris Pirillo">
    <link rel="canonical" href="https://pirillo.com/arcade/neotropolis.html">

    <!-- Open Graph / Facebook Card -->
    <meta property="og:title" content="Neotropolis - An Interactive WebGL Shader Experience">
    <meta property="og:description" content="A real-time, interactive WebGL shader art experience where you can customize psychedelic, abstract cityscapes.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://pirillo.com/arcade/neotropolis.html">
    <meta property="og:image" content="https://pirillo.com/arcade/images/neotropolis.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:site_name" content="Chris Pirillo's Arcade">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@ChrisPirillo">
    <meta name="twitter:creator" content="@ChrisPirillo">
    <meta name="twitter:title" content="Neotropolis - An Interactive WebGL Shader Experience">
    <meta name="twitter:description" content="A real-time, interactive WebGL shader art experience where you can customize psychedelic, abstract cityscapes.">
    <meta name="twitter:image" content="https://pirillo.com/arcade/images/neotropolis.png">
    
    <!--
    ================================================================================================================
    |                            PERFORMANCE & RESOURCE HINTS                                                        |
    ================================================================================================================
    -->
    <!-- Preconnect to critical third-party origins to speed up DNS lookup, TCP handshake, and TLS negotiation. -->
    <link rel="preconnect" href="https://cdn.tailwindcss.com">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://www.googletagmanager.com">

    <!-- Preload critical CSS for fonts. This is loaded asynchronously to avoid render-blocking. -->
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <!-- Fallback for browsers without JavaScript -->
    <noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap"></noscript>
    
    <!-- Tailwind CSS is critical for the UI layout and is kept as a render-blocking resource as requested. -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!--
    ================================================================================================================
    |                            ANALYTICS & STRUCTURED DATA                                                         |
    ================================================================================================================
    -->
    <!-- Google Analytics - loaded asynchronously to not impact performance -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-1CQ4D3VQ3L"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-1CQ4D3VQ3L');
    </script>

    <!-- JSON-LD Structured Data for enhanced search result appearance -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "Neotropolis",
      "description": "Explore Neotropolis, a real-time, interactive WebGL shader art experience. Customize psychedelic, abstract cityscapes and visual effects directly in your browser.",
      "url": "https://pirillo.com/arcade/neotropolis.html",
      "applicationCategory": "GameApplication",
      "operatingSystem": "All",
      "browserRequirements": "Requires WebGL",
      "screenshot": "https://pirillo.com/arcade/images/neotropolis.png",
      "author": {
        "@type": "Person",
        "name": "Chris Pirillo",
        "url": "https://chris.pirillo.com/"
      },
      "creator": {
        "@type": "Person",
        "name": "Chris Pirillo",
        "url": "https://chris.pirillo.com/"
      }
    }
    </script>
    
    <!--
    ================================================================================================================
    |                            CRITICAL INLINE STYLES                                                              |
    ================================================================================================================
    -->
    <!-- Critical CSS is inlined here to ensure the fastest possible First Contentful Paint (FCP) -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Prevent scrollbars from the canvas */
            user-select: none; /* Standard syntax */
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none; /* Internet Explorer/Edge */
        }
        #glcanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        /* Menu styles */
        #menu {
            position: fixed;
            top: 0;
            left: -320px; /* Hidden by default */
            width: 300px;
            height: 100%;
            background-color: rgba(17, 24, 39, 0.9);
            backdrop-filter: blur(10px);
            z-index: 5; /* Increased z-index */
            transition: left 0.3s ease-in-out;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }
        #menu.open {
            left: 0;
        }
        /* Hamburger button styles */
        #menu-button {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 4;
            cursor: pointer;
            width: 32px;
            height: 24px;
            background: none;
            border: none;
            padding: 0;
            opacity: 1;
            transition: opacity 0.2s ease-out;
        }

        #menu.open ~ #menu-button {
            opacity: 0;
            pointer-events: none;
        }

        #menu-button span {
            display: block;
            width: 100%;
            height: 3px;
            background-color: white;
            border-radius: 3px;
            position: relative;
        }
        #menu-button span:nth-of-type(1) {
            transform-origin: 0% 0%;
        }
        #menu-button span:nth-of-type(2) {
             margin: 6px 0;
        }
        #menu-button span:nth-of-type(3) {
            transform-origin: 0% 100%;
        }
        
        #close-button {
            position: relative;
            z-index: 6;
            cursor: pointer;
            width: 24px;
            height: 24px;
            background: none;
            border: none;
            padding: 0;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease-in 0.1s;
        }
        #menu.open #close-button {
            opacity: 1;
            pointer-events: auto;
        }
        #close-button span {
            display: block;
            width: 100%;
            height: 3px;
            background-color: #cbd5e0; /* Lighter gray for X */
            border-radius: 3px;
            position: absolute;
            top: 50%;
            left: 0;
            transform-origin: center;
        }
        #close-button:hover span {
             background-color: #ffffff;
        }
        #close-button span:nth-of-type(1) {
            transform: translateY(-50%) rotate(45deg);
        }
        #close-button span:nth-of-type(2) {
            transform: translateY(-50%) rotate(-45deg);
        }
        
        /* Custom slider styles */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #4a5568;
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type="range"]:hover {
            opacity: 1;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #90cdf4;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #2c5282;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #90cdf4;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #2c5282;
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <!-- Use of semantic <nav> for the settings panel for better accessibility and SEO -->
    <nav id="menu" aria-label="Neotropolis Settings">
        <div class="p-6 h-full overflow-y-auto">
            <div class="flex justify-between items-center mb-6">
                <h1 class="text-2xl font-bold text-blue-300">Neotropolis</h1>
                <button id="close-button" aria-label="Close Settings">
                    <span></span>
                    <span></span>
                </button>
            </div>
            
            <!-- Parameter controls will be dynamically added here -->
            <div id="controls-container" class="space-y-6"></div>

            <div class="mt-8 pt-6 border-t border-gray-700">
                <button id="reset-button" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                    Reset to Defaults
                </button>
            </div>
        </div>
    </nav>

    <!-- The main content area, containing the canvas and interactive elements -->
    <main>
        <!-- WebGL Canvas -->
        <canvas id="glcanvas" aria-label="Interactive WebGL animation of Neotropolis"></canvas>

        <!-- Hamburger Menu Button -->
        <button id="menu-button" aria-label="Open Settings">
            <span></span>
            <span></span>
            <span></span>
        </button>
    </main>

    <!-- Vertex and Fragment shaders for WebGL -->
    <script type="x-shader/x-vertex" id="vertex-shader">
        attribute vec4 a_position;
        void main() {
            gl_Position = a_position;
        }
    </script>

    <script type="x-shader/x-fragment" id="fragment-shader">
        precision mediump float;
        uniform vec2 u_resolution;
        uniform float u_time;
        
        // User-configurable uniforms
        uniform float u_iterations;
        uniform float u_scale;
        uniform vec3 u_color_vec;
        uniform float u_tan_freq;
        uniform float u_cos_freq;
        uniform float u_dot_factor;
        uniform float u_y_offset;
        uniform float u_tanh_factor;
        uniform float u_d_multiplier;
        uniform float u_sin_swizzle_amp;
        uniform vec2 u_animation_direction;
        uniform float u_horizon_offset;

        const float MAX_ITERATIONS = 150.0;

        // tanh is not a built-in function in WebGL1 (GLSL ES 1.0)
        vec3 tanh_impl(vec3 x) {
            vec3 ex2 = exp(2.0 * x);
            return (ex2 - 1.0) / (ex2 + 1.0);
        }

        void main() {
            vec2 r = u_resolution;
            float t = u_time;
            vec4 o = vec4(0.0);
            
            vec3 c, p, v;
            float z = 0.0, d = 0.0;

            for(float i = 0.0; i < MAX_ITERATIONS; i++) {
                if (i >= u_iterations) break;

                // This is the core logic from the original one-liner, restored.
                // Note: Execution order in the original `for` loop is right-to-left.

                // 1. Calculate the distance field `d`
                // v=p-sin(p).xxz is an approximation. Let's use a controllable factor.
                v = p - sin(p) * u_sin_swizzle_amp;
                d = u_scale * max(dot(cos(v).xz, sin(v.zx / u_dot_factor)) + u_dot_factor, v.y + u_y_offset);
                
                // 2. Advance the ray
                z += d;

                // 3. Update the world-space position `p`
                p = z * c;
                p.xz -= t * u_animation_direction;

                // 4. Recalculate ray direction `c` *inside the loop*. This is the key to the original's look.
                // The original 'FC.rgb*2.-r.xxy' is tricky. gl_FragCoord is a vec4, so .rgb is valid and gives (x,y,z_depth).
                // This uses the screen coordinates and depth buffer to alter the ray direction at every step.
                vec3 ray_base = gl_FragCoord.rgb * 2.0 - r.xxy;
                ray_base.y += u_horizon_offset;
                c = normalize(ray_base);

                // 5. Accumulate color (after all other updates for the step)
                // The check `z > 0.0` prevents division by zero on the first iteration.
                if (z > 0.0) {
                    o.rgb += -c*d*d/(z*z) + (cos(p.y + u_color_vec) + 1.1) / (length(tan(p.y/u_tan_freq) / cos(p.xz/u_cos_freq)) + d*d/u_d_multiplier) / z;
                }
                
                // Bail out if the ray goes too far or the step is too small
                if (z > 100.0 || d < 0.001) break;
            }
            
            o.rgb = tanh_impl(u_tanh_factor * o.rgb);
            o.a = 1.0;
            
            gl_FragColor = o;
        }
    </script>
    
    <!--
    ================================================================================================================
    |                            MAIN APPLICATION JAVASCRIPT (UNALTERED)                                             |
    ================================================================================================================
    -->
    <!-- The 'defer' attribute ensures this script runs after the HTML is parsed, preventing it from blocking the page render. -->
    <!-- This improves First Input Delay (FID) and the overall Lighthouse performance score. -->
    <script defer>
        // --- Configuration for Shader Parameters ---
        // Defaults are now set to match the original formula's "magic numbers"
        const shaderParams = {
            iterations:   { value: 50.0, min: 5, max: 150, step: 1, label: "Iterations" },
            scale:        { value: 0.4, min: 0.1, max: 2.0, step: 0.01, label: "Scale" },
            tan_freq:     { value: 0.3, min: 0.01, max: 2.0, step: 0.01, label: "Tan Frequency" },
            cos_freq:     { value: 0.1, min: 0.01, max: 1.0, step: 0.01, label: "Cos Frequency" },
            dot_factor:   { value: 0.6, min: 0.1, max: 3.0, step: 0.01, label: "Dot Factor" },
            y_offset:     { value: 3.0, min: 0.6, max: 10.0, step: 0.1, label: "Y Offset (Ground)" },
            tanh_factor:  { value: 0.1, min: 0.01, max: 1.0, step: 0.01, label: "Contrast (Tanh)" },
            d_multiplier: { value: 0.01, min: 0.001, max: 0.1, step: 0.001, label: "Detail Multiplier" },
            sin_swizzle_amp: { value: 1.0, min: 0.0, max: 2.0, step: 0.01, label: "Sine Vector Amp" },
            color_vec_r:  { value: 6.0, min: 0.0, max: 10.0, step: 0.1, label: "Color R" },
            color_vec_g:  { value: 1.0, min: 0.0, max: 10.0, step: 0.1, label: "Color G" },
            color_vec_b:  { value: 2.0, min: 0.0, max: 10.0, step: 0.1, label: "Color B" },
            horizon_offset: { value: 0.0, min: -500.0, max: 500.0, step: 1.0, label: "Horizon Offset" },
            animation_direction_x: { value: 1.0, min: -2.0, max: 2.0, step: 0.1, label: "Anim Dir X" },
            animation_direction_z: { value: 1.0, min: -2.0, max: 2.0, step: 0.1, label: "Anim Dir Z" },
        };
        const defaultParams = JSON.parse(JSON.stringify(shaderParams));

        // --- Main Application Logic ---
        function main() {
            const canvas = document.getElementById('glcanvas');
            // Enable preserveDrawingBuffer for feedback effects if needed, and antialias
            const gl = canvas.getContext('webgl', { antialias: true, preserveDrawingBuffer: true });
            if (!gl) {
                const msg = 'WebGL not supported! Please use a modern browser.';
                const errorDiv = document.createElement('div');
                errorDiv.style.position = 'fixed';
                errorDiv.style.top = '0';
                errorDiv.style.left = '0';
                errorDiv.style.width = '100%';
                errorDiv.style.padding = '20px';
                errorDiv.style.backgroundColor = '#f44336';
                errorDiv.style.color = 'white';
                errorDiv.style.textAlign = 'center';
                errorDiv.style.zIndex = '100';
                errorDiv.innerText = msg;
                document.body.appendChild(errorDiv);
                return;
            }

            const vertexShader = createShader(gl, gl.VERTEX_SHADER, document.getElementById('vertex-shader').text);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, document.getElementById('fragment-shader').text);
            if (!vertexShader || !fragmentShader) return;
            const program = createProgram(gl, vertexShader, fragmentShader);
            if (!program) return;

            const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
            const resolutionUniformLocation = gl.getUniformLocation(program, "u_resolution");
            const timeUniformLocation = gl.getUniformLocation(program, "u_time");
            
            const uniformLocations = {};
            for (const key in shaderParams) {
                if(key.startsWith('color_vec_')) continue;
                if(key.startsWith('animation_direction_')) continue;
                uniformLocations[key] = gl.getUniformLocation(program, `u_${key}`);
            }
            uniformLocations.color_vec = gl.getUniformLocation(program, 'u_color_vec');
            uniformLocations.animation_direction = gl.getUniformLocation(program, 'u_animation_direction');

            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            const positions = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

            let startTime = Date.now();
            
            // --- UI Setup ---
            const controlsContainer = document.getElementById('controls-container');
            for (const key in shaderParams) {
                const param = shaderParams[key];
                const controlDiv = document.createElement('div');
                
                const label = document.createElement('label');
                label.className = "block text-sm font-medium text-gray-300 mb-2 flex justify-between";
                
                const labelText = document.createElement('span');
                labelText.textContent = param.label;
                
                const valueSpan = document.createElement('span');
                valueSpan.id = `value-${key}`;
                valueSpan.textContent = param.value.toFixed(param.step < 1 ? 2 : 0);
                valueSpan.className = "font-mono text-blue-300";

                label.appendChild(labelText);
                label.appendChild(valueSpan);

                const slider = document.createElement('input');
                slider.type = 'range';
                slider.min = param.min;
                slider.max = param.max;
                slider.step = param.step;
                slider.value = param.value;
                slider.dataset.key = key;

                slider.addEventListener('input', (e) => {
                    const key = e.target.dataset.key;
                    shaderParams[key].value = parseFloat(e.target.value);
                    document.getElementById(`value-${key}`).textContent = shaderParams[key].value.toFixed(param.step < 1 ? 2 : 0);
                });
                
                controlDiv.appendChild(label);
                controlDiv.appendChild(slider);
                controlsContainer.appendChild(controlDiv);
            }

            const menuButton = document.getElementById('menu-button');
            const closeButton = document.getElementById('close-button');
            const menu = document.getElementById('menu');
            
            menuButton.addEventListener('click', () => menu.classList.add('open'));
            closeButton.addEventListener('click', () => menu.classList.remove('open'));

            document.getElementById('reset-button').addEventListener('click', () => {
                Object.assign(shaderParams, JSON.parse(JSON.stringify(defaultParams)));
                 const sliders = controlsContainer.querySelectorAll('input[type="range"]');
                 sliders.forEach(slider => {
                    const key = slider.dataset.key;
                    slider.value = shaderParams[key].value;
                    document.getElementById(`value-${key}`).textContent = shaderParams[key].value.toFixed(shaderParams[key].step < 1 ? 2 : 0);
                 });
            });

            function render() {
                resizeCanvasToDisplaySize(gl.canvas);
                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);

                gl.useProgram(program);
                gl.enableVertexAttribArray(positionAttributeLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
                
                gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
                gl.uniform1f(timeUniformLocation, (Date.now() - startTime) * 0.001);

                for (const key in shaderParams) {
                    if(key.startsWith('color_vec_')) continue;
                    if(key.startsWith('animation_direction_')) continue;
                    gl.uniform1f(uniformLocations[key], shaderParams[key].value);
                }
                gl.uniform3f(uniformLocations.color_vec, shaderParams.color_vec_r.value, shaderParams.color_vec_g.value, shaderParams.color_vec_b.value);
                gl.uniform2f(uniformLocations.animation_direction, shaderParams.animation_direction_x.value, shaderParams.animation_direction_z.value);

                gl.drawArrays(gl.TRIANGLES, 0, 6);
                requestAnimationFrame(render);
            }

            requestAnimationFrame(render);
        }

        // --- WebGL Helper Functions ---
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) return shader;
            console.error(`Error compiling shader: ${type === gl.VERTEX_SHADER ? 'VERTEX' : 'FRAGMENT'}`);
            console.error(gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (gl.getProgramParameter(program, gl.LINK_STATUS)) return program;
            console.error('Error linking program:', gl.getProgramInfoLog(program));
            gl.deleteProgram(program);
            return null;
        }

        function resizeCanvasToDisplaySize(canvas) {
            const displayWidth  = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth;
                canvas.height = displayHeight;
                return true;
            }
            return false;
        }

        main();
    </script>
</body>
</html>
